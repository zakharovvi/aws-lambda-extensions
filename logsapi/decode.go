package logsapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/zakharovvi/aws-lambda-extensions/extapi"
)

// LogType represents the type of logs received from Lambda Logs API.
type LogType string

const (
	// LogPlatformStart is the invocation start time.
	LogPlatformStart LogType = "platform.start"
	// LogPlatformEnd is the invocation end time.
	LogPlatformEnd LogType = "platform.end"
	// LogPlatformReport includes metrics about the invocation that the requestId specifies.
	LogPlatformReport LogType = "platform.report"
	// LogPlatformExtension is generated when an extension registers with the extensions API.
	LogPlatformExtension LogType = "platform.extension"
	// LogPlatformLogsSubscription is generated when an extension subscribes to the logs API.
	LogPlatformLogsSubscription LogType = "platform.logsSubscription"
	// LogPlatformLogsDropped is generated when an extension is not able to process the number of logs that it is receiving.
	LogPlatformLogsDropped LogType = "platform.logsDropped"
	// LogPlatformFault log captures runtime or execution environment errors.
	LogPlatformFault LogType = "platform.fault"
	// LogPlatformRuntimeDone is generated after the function invocation completes either successfully or with an error.
	// The extension can use this message to stop all the telemetry collection for this function invocation.
	// Lambda sends the platform.runtimeDone message after the runtime sends the NEXT request when the function invocation completes.
	LogPlatformRuntimeDone LogType = "platform.runtimeDone"
	// LogFunction logs are generated by the lambda function and internal extensions and written to stdout or stderr.
	LogFunction LogType = "function"
	// LogExtension logs are generated by extensions and written to stdout or stderr.
	LogExtension LogType = "extension"
)

// Log is a parsed log record from Lambda Logs API.
// Use type assertion for Log.Record field to access custom fields of current Log.LogType.
type Log struct {
	LogType   LogType         `json:"type"`
	Time      time.Time       `json:"time"`
	RawRecord json.RawMessage `json:"record"`
	Record    any             `json:"-"`
}

// RecordPlatformStart is the invocation start time.
type RecordPlatformStart struct {
	RequestID string `json:"requestId"`
	Version   string `json:"version,omitempty"`
}

// RecordPlatformEnd is the invocation end time.
type RecordPlatformEnd struct {
	RequestID string `json:"requestId"`
}

// RecordPlatformReport includes metrics about the invocation that the requestId specifies.
type RecordPlatformReport struct {
	Metrics   Metrics `json:"metrics"`
	RequestID string  `json:"requestId"`
	// Tracing field is included if AWS X-Ray tracing is active, the log includes X-Ray metadata.
	Tracing extapi.Tracing `json:"tracing,omitempty"`
}

type Duration time.Duration

func (d *Duration) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	*d = Duration(v * float64(time.Millisecond))

	return nil
}

type Metrics struct {
	Duration       Duration `json:"durationMs"`
	BilledDuration Duration `json:"billedDurationMs"`
	// InitDuration field is included in the log only if the invocation included a cold start.
	InitDuration    Duration `json:"initDurationMs"`
	MemorySizeMB    uint64   `json:"memorySizeMB"`
	MaxMemoryUsedMB uint64   `json:"maxMemoryUsedMB"`
}

// RecordPlatformExtension is generated when an extension registers with the extensions API.
type RecordPlatformExtension struct {
	Events []extapi.EventType `json:"events"`
	Name   string             `json:"name"`
	State  string             `json:"state"`
}

// RecordPlatformLogsSubscription is generated when an extension subscribes to the logs API.
type RecordPlatformLogsSubscription struct {
	Name  string                       `json:"name"`
	State string                       `json:"state"`
	Types []extapi.LogSubscriptionType `json:"types"`
}

// RecordPlatformLogsDropped is generated when an extension is not able to process the number of logs that it is receiving.
type RecordPlatformLogsDropped struct {
	DroppedBytes   uint64 `json:"droppedBytes"`
	DroppedRecords uint64 `json:"droppedRecords"`
	Reason         string `json:"reason"`
}

// RecordPlatformFault log captures runtime or execution environment errors.
type RecordPlatformFault string

// RecordPlatformRuntimeDone is generated after the function invocation completes either successfully or with an error.
// The extension can use this message to stop all the telemetry collection for this function invocation.
// Lambda sends the platform.runtimeDone message after the runtime sends the NEXT request when the function invocation completes.
type RecordPlatformRuntimeDone struct {
	RequestID string            `json:"requestId"`
	Status    RuntimeDoneStatus `json:"status"`
}
type RuntimeDoneStatus string

const (
	RuntimeDoneSuccess RuntimeDoneStatus = "success"
	RuntimeDoneFailure RuntimeDoneStatus = "failure"
	RuntimeDoneTimeout RuntimeDoneStatus = "timeout"
)

// RecordFunction logs are generated by the lambda function and internal extensions and written to stdout or stderr.
type RecordFunction string

// RecordExtension logs are generated by extensions and written to stdout or stderr.
type RecordExtension string

// DecodeLogs consumes all logs from json array stream and send them to the provided channel.
// DecodeLogs is low-level function. Consider using Run instead and implement LogProcessor.
// DecodeLogs drains and closes the input stream afterwards.
func DecodeLogs(ctx context.Context, r io.ReadCloser, logs chan<- Log) error {
	defer func() {
		_, _ = io.Copy(io.Discard, r)
		_ = r.Close()
	}()

	d := json.NewDecoder(r)
	if err := readBracket(d, "["); err != nil {
		return err
	}
	for d.More() {
		msg := Log{}
		if err := d.Decode(&msg); err != nil {
			return fmt.Errorf("could not decode log message from json array: %w", err)
		}
		var unmarshalErr error
		switch msg.LogType {
		case LogPlatformStart:
			record := RecordPlatformStart{}
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogPlatformEnd:
			record := RecordPlatformEnd{}
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogPlatformReport:
			record := RecordPlatformReport{}
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogPlatformExtension:
			record := RecordPlatformExtension{}
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogPlatformLogsSubscription:
			record := RecordPlatformLogsSubscription{}
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogPlatformLogsDropped:
			record := RecordPlatformLogsDropped{}
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogPlatformFault:
			record := RecordPlatformFault("")
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogPlatformRuntimeDone:
			record := RecordPlatformRuntimeDone{}
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogFunction:
			record := RecordFunction("")
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		case LogExtension:
			record := RecordExtension("")
			unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
			msg.Record = record
		default:
			return fmt.Errorf(`could not decode unknown log type "%s" and record "%s"`, msg.LogType, msg.RawRecord)
		}
		if unmarshalErr != nil {
			return fmt.Errorf("could not decode log record %s for log type %s with error: %w", msg.RawRecord, msg.LogType, unmarshalErr)
		}

		select {
		case <-ctx.Done():
			return fmt.Errorf("decoding was interrupted with context error: %w", ctx.Err())
		default:
		}
		logs <- msg
	}
	if err := readBracket(d, "]"); err != nil {
		return err
	}

	return nil
}

func readBracket(d *json.Decoder, want string) error {
	t, err := d.Token()
	if err != nil {
		return fmt.Errorf("malformed json array: %w", err)
	}
	delim, ok := t.(json.Delim)
	if !ok {
		return fmt.Errorf("malformed json array, want %s, got %v", want, t)
	}
	if delim.String() != want {
		return fmt.Errorf("malformed json array, want %s, got %v", want, delim.String())
	}

	return nil
}
