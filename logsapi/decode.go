package logsapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	lambdaext "github.com/zakharovvi/aws-lambda-extensions"
	"github.com/zakharovvi/aws-lambda-extensions/extapi"
	"github.com/zakharovvi/aws-lambda-extensions/internal"
)

// LogType represents the type of logs received from Lambda Logs API.
type LogType string

const (
	// LogPlatformStart is the invocation start time.
	LogPlatformStart LogType = "platform.start"
	// LogPlatformEnd is the invocation end time.
	LogPlatformEnd LogType = "platform.end"
	// LogPlatformReport includes metrics about the invocation that the lambdaext.RequestID specifies.
	LogPlatformReport LogType = "platform.report"
	// LogPlatformExtension is generated when an extension registers with the extensions API.
	LogPlatformExtension LogType = "platform.extension"
	// LogPlatformLogsSubscription is generated when an extension subscribes to the logs API.
	LogPlatformLogsSubscription LogType = "platform.logsSubscription"
	// LogPlatformLogsDropped is generated when an extension is not able to process the number of logs that it is receiving.
	LogPlatformLogsDropped LogType = "platform.logsDropped"
	// LogPlatformFault log captures runtime or execution environment errors.
	LogPlatformFault LogType = "platform.fault"
	// LogPlatformRuntimeDone is generated after the function invocation completes either successfully or with an error.
	// The extension can use this message to stop all the telemetry collection for this function invocation.
	// Lambda sends the platform.runtimeDone message after the runtime sends the NEXT request when the function invocation completes.
	LogPlatformRuntimeDone LogType = "platform.runtimeDone"
	// LogFunction logs are generated by the lambda function and internal extensions and written to stdout or stderr.
	LogFunction LogType = "function"
	// LogExtension logs are generated by extensions and written to stdout or stderr.
	LogExtension LogType = "extension"
)

// Log is a parsed log record from Lambda Logs API.
// Use type assertion for Log.Record field to access custom fields of current Log.LogType.
type Log struct {
	// Type property defines the event type.
	// The following table describes all possible values.
	LogType LogType `json:"type"`
	// Time property defines when the Lambda platform generated the event.
	// This isn't the same as when the event actually occurred.
	// The string value of time is a timestamp in ISO 8601 format.
	Time time.Time `json:"time"`
	// RawRecord property defines a JSON object that contains the telemetry data.
	// The schema of this JSON object depends on the type.
	RawRecord json.RawMessage `json:"record"`
	// Record property defines a struct that contains the telemetry data.
	// The type of the struct depends on the Log.LogType
	Record any `json:"decodedRecord,omitempty"` // tag for printing the field with json.Marshall
}

// RecordPlatformStart is the invocation start time.
type RecordPlatformStart struct {
	RequestID lambdaext.RequestID       `json:"requestId"`
	Version   lambdaext.FunctionVersion `json:"version,omitempty"`
}

// RecordPlatformEnd is the invocation end time.
type RecordPlatformEnd struct {
	RequestID lambdaext.RequestID `json:"requestId"`
}

// RecordPlatformReport includes metrics about the invocation that the lambdaext.RequestID specifies.
type RecordPlatformReport struct {
	Metrics   Metrics             `json:"metrics"`
	RequestID lambdaext.RequestID `json:"requestId"`
	// Tracing field is included if AWS X-Ray tracing is active, the log includes X-Ray metadata.
	Tracing extapi.Tracing `json:"tracing,omitempty"`
}

type Metrics struct {
	Duration       lambdaext.DurationMs `json:"durationMs"`
	BilledDuration lambdaext.DurationMs `json:"billedDurationMs"`
	// InitDuration field is included in the log only if the invocation included a cold start.
	InitDuration    lambdaext.DurationMs `json:"initDurationMs"`
	MemorySizeMB    uint64               `json:"memorySizeMB"`
	MaxMemoryUsedMB uint64               `json:"maxMemoryUsedMB"`
}

// RecordPlatformExtension is generated when an extension registers with the extensions API.
type RecordPlatformExtension struct {
	Events []extapi.EventType      `json:"events"`
	Name   lambdaext.ExtensionName `json:"name"`
	State  string                  `json:"state"`
}

// RecordPlatformLogsSubscription is generated when an extension subscribes to the logs API.
type RecordPlatformLogsSubscription struct {
	Name  lambdaext.ExtensionName      `json:"name"`
	State string                       `json:"state"`
	Types []extapi.LogSubscriptionType `json:"types"`
}

// RecordPlatformLogsDropped is generated when an extension is not able to process the number of logs that it is receiving.
type RecordPlatformLogsDropped struct {
	DroppedBytes   uint64 `json:"droppedBytes"`
	DroppedRecords uint64 `json:"droppedRecords"`
	Reason         string `json:"reason"`
}

// RecordPlatformFault log captures runtime or execution environment errors.
type RecordPlatformFault string

// RecordPlatformRuntimeDone is generated after the function invocation completes either successfully or with an error.
// The extension can use this message to stop all the telemetry collection for this function invocation.
// Lambda sends the platform.runtimeDone message after the runtime sends the NEXT request when the function invocation completes.
type RecordPlatformRuntimeDone struct {
	RequestID lambdaext.RequestID `json:"requestId"`
	Status    RuntimeDoneStatus   `json:"status"`
}
type RuntimeDoneStatus string

const (
	RuntimeDoneSuccess RuntimeDoneStatus = "success"
	RuntimeDoneFailure RuntimeDoneStatus = "failure"
	RuntimeDoneTimeout RuntimeDoneStatus = "timeout"
)

// RecordFunction logs are generated by the lambda function and internal extensions and written to stdout or stderr.
type RecordFunction string

// RecordExtension logs are generated by extensions and written to stdout or stderr.
type RecordExtension string

// DecodeLogs consumes all logs from json array stream and send them to the provided channel.
// DecodeLogs is low-level function. Consider using Run instead and implement LogProcessor.
// DecodeLogs drains and closes the input stream afterwards.
func DecodeLogs(ctx context.Context, r io.ReadCloser, logs chan<- Log) error {
	return internal.Decode(ctx, r, logs, decodeNext)
}

func decodeNext(d *json.Decoder) (Log, error) {
	msg := Log{}
	if err := d.Decode(&msg); err != nil {
		return msg, fmt.Errorf("could not decode log message from json array: %w", err)
	}
	var unmarshalErr error
	switch msg.LogType {
	case LogPlatformStart:
		record := RecordPlatformStart{}
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogPlatformEnd:
		record := RecordPlatformEnd{}
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogPlatformReport:
		record := RecordPlatformReport{}
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogPlatformExtension:
		record := RecordPlatformExtension{}
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogPlatformLogsSubscription:
		record := RecordPlatformLogsSubscription{}
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogPlatformLogsDropped:
		record := RecordPlatformLogsDropped{}
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogPlatformFault:
		record := RecordPlatformFault("")
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogPlatformRuntimeDone:
		record := RecordPlatformRuntimeDone{}
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogFunction:
		record := RecordFunction("")
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	case LogExtension:
		record := RecordExtension("")
		unmarshalErr = json.Unmarshal(msg.RawRecord, &record)
		msg.Record = record
	default:
		return msg, fmt.Errorf(`could not decode unknown log type "%s" and record "%s"`, msg.LogType, msg.RawRecord)
	}
	if unmarshalErr != nil {
		return msg, fmt.Errorf("could not decode log record %s for log type %s with error: %w", msg.RawRecord, msg.LogType, unmarshalErr)
	}
	return msg, nil
}
